# -*- coding:utf-8 -*-"""Created at 2:26 PM 1/14/2020This is just to test with python multi-processing@author: guangqiang.lu"""from multiprocessing import Processfrom multiprocessing import Poolimport threadingimport multiprocessing# def s(num):#     # this is to get current threading number.#     print("Now is process: %d, number: %d" % (threading.get_ident(), num))## def job(num):#     return num ** 2from sklearn.datasets import load_iris, load_digitsfrom sklearn.linear_model import LogisticRegression, Lasso, Ridgeimport warningswarnings.simplefilter('ignore')x, y = load_digits(return_X_y=True)lr = LogisticRegression()# if __name__ == '__main__':#     # for i in range(5):#     #     p = Process(target=s, args=(i, ))#     #     p.start()#     #     p.join()#     # p = Pool(processes=8)#     # data = p.map(job, [i for i in range(10)])#     # p.close()#     # print("Get data:", data)models = [LogisticRegression(), Lasso(), Ridge()]def fit_model_with_share(model, return_dict):    model.fit(x, y)    return_dict[str(model)] = modeldef fit_model_with_pool(model):    return model.fit(x, y)# test with multi-processing to train modelsdef fit_with_shared_manager():    manager = multiprocessing.Manager()    return_dict = manager.dict()    processes = []    for i in range(len(models)):        p = Process(target=fit_model_with_share, args=(models[i], return_dict))        processes.append(p)        p.start()    for p in processes: p.join()    print("accuracy: ", [model.score(x, y) for model in return_dict.values()])def fit_with_pool(synch=True):    pool = multiprocessing.Pool(processes=len(models))    # even with asynch training, we don't get much improvement in time.    if synch:        trained_model = pool.map(fit_model_with_pool, models)    else:        trained_model = pool.imap_unordered(fit_model_with_pool, models)    for model in trained_model:        print("%s accuracy: %f" % (model.__class__.__name__, model.score(x,  y)))# if __name__ == '__main__':# #     # fit_with_shared_manager()# #     import time# #     start_with_pool = time.time()# #     models = [LogisticRegression(), Lasso(), Ridge()]# #     fit_with_pool()# #     end_with_pool = time.time()# ## #     start_with_pool_asych = time.time()# #     models = [LogisticRegression(), Lasso(), Ridge()]# #     fit_with_pool(False)# #     end_with_pool_asych = time.time()# ## #     start_with_manager = time.time()# #     models = [LogisticRegression(), Lasso(), Ridge()]# #     fit_with_shared_manager()# #     end_with_manager = time.time()# ## #     start_with_loop = time.time()# #     models = [LogisticRegression(), Lasso(), Ridge()]# #     for model in models:# #         model.fit(x, y)# #         print("%s accuracy: %f" % (model.__class__.__name__, model.score(x,  y)))# #     end_with_loop = time.time()# ## #     print("with pool time: ", end_with_pool - start_with_pool)# #     print("with loop time: ", end_with_loop - start_with_loop)# #     print("with manager time: ", end_with_manager - start_with_manager)# #     print("with asynch pool time: ", end_with_pool_asych - start_with_pool_asych)import timedef cpu_func(result, niters):    '''    A useless CPU bound function.    '''    for i in range(niters):        result = (result * result * i + 2 * result * i * i + 3) % 10000000    return resultclass CpuThread(threading.Thread):    def __init__(self, niters):        super().__init__()        self.niters = niters        self.result = 1    def run(self):        self.result = cpu_func(self.result, self.niters)class CpuProcess(multiprocessing.Process):    def __init__(self, niters):        super().__init__()        self.niters = niters        self.result = 1    def run(self):        self.result = cpu_func(self.result, self.niters)class IoThread(threading.Thread):    def __init__(self, sleep):        super().__init__()        self.sleep = sleep        self.result = self.sleep    def run(self):        time.sleep(self.sleep)class IoProcess(multiprocessing.Process):    def __init__(self, sleep):        super().__init__()        self.sleep = sleep        self.result = self.sleep    def run(self):        time.sleep(self.sleep)if __name__ == '__main__':    cpu_n_iters = 10    sleep = 1    cpu_count = multiprocessing.cpu_count()    input_params = [        (CpuThread, cpu_n_iters),        (CpuProcess, cpu_n_iters),        (IoThread, sleep),        (IoProcess, sleep),    ]    header = ['nthreads']    for thread_class, _ in input_params:        header.append(thread_class.__name__)    print(' '.join(header))    for nthreads in range(1, 2 * cpu_count):        results = [nthreads]        for thread_class, work_size in input_params:            start_time = time.time()            threads = []            for i in range(nthreads):                thread = thread_class(work_size)                threads.append(thread)                thread.start()            for i, thread in enumerate(threads):                thread.join()            results.append(time.time() - start_time)        print(' '.join('{:.6e}'.format(result) for result in results))